



<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>NITRO DUEL: 1v1 Multiplayer</title>

<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>

<style>
    /* --- CSS STYLES --- */
    :root { --primary: #00e5ff; --secondary: #ff0055; --bg: #121212; --hud-bg: rgba(0,0,0,0.6); }
    body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: var(--bg); font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; touch-action: none; }
    
    /* LAYERS */
    #game-container { position: relative; width: 100%; height: 100%; }
    canvas { display: block; width: 100%; height: 100%; }
    
    /* UI OVERLAYS */
    .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background: rgba(0,0,0,0.85); color: white; z-index: 10; transition: opacity 0.3s; }
    .hidden { display: none !important; }
    
    /* TYPOGRAPHY */
    h1 { font-size: 3rem; text-transform: uppercase; letter-spacing: 5px; color: var(--primary); text-shadow: 0 0 20px var(--primary); margin: 0 0 20px 0; font-style: italic; }
    p { font-size: 1.2rem; color: #ccc; }
    
    /* FORMS & BUTTONS */
    input { padding: 15px; font-size: 1.2rem; border-radius: 5px; border: 2px solid var(--primary); background: #000; color: white; text-align: center; margin-bottom: 20px; outline: none; }
    button { padding: 15px 50px; font-size: 1.5rem; font-weight: bold; background: linear-gradient(45deg, var(--primary), #0099cc); border: none; color: #000; border-radius: 5px; cursor: pointer; box-shadow: 0 0 15px var(--primary); transition: transform 0.1s; text-transform: uppercase; }
    button:active { transform: scale(0.95); }
    button:disabled { background: #555; color: #888; cursor: not-allowed; box-shadow: none; }

    /* HUD */
    #hud { pointer-events: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    .top-bar { display: flex; justify-content: space-between; padding: 20px; font-size: 1.5rem; font-weight: bold; color: white; text-shadow: 1px 1px 0 #000; }
    .stat-box { background: var(--hud-bg); padding: 5px 15px; border-radius: 4px; border-left: 4px solid var(--primary); }
    
    .center-msg { position: absolute; top: 30%; width: 100%; text-align: center; font-size: 4rem; font-weight: 900; color: #fff; text-shadow: 0 5px 15px #000; letter-spacing: 5px; animation: popIn 0.5s ease-out; }
    
    .speedometer { position: absolute; bottom: 20px; right: 20px; text-align: right; color: white; }
    .speed-val { font-size: 4rem; font-weight: bold; font-style: italic; }
    .speed-label { font-size: 1rem; color: var(--primary); }

    /* MOBILE CONTROLS */
    .controls-layer { display: none; position: absolute; bottom: 20px; width: 100%; height: 150px; pointer-events: none; justify-content: space-between; padding: 0 20px; box-sizing: border-box; }
    .btn-touch { pointer-events: auto; width: 80px; height: 80px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.3); border-radius: 50%; display: flex; justify-content: center; align-items: center; color: white; font-size: 24px; backdrop-filter: blur(4px); touch-action: manipulation; }
    .btn-touch:active { background: var(--primary); color: black; }
    
    .d-pad { display: flex; gap: 20px; margin-top: 50px; }
    .pedals { display: flex; gap: 20px; align-items: flex-end; }
    .pedal-gas { height: 100px; border-color: #0f0; }
    .pedal-brake { height: 60px; border-color: #f00; }

    /* SHOW TOUCH ON MOBILE */
    @media (max-width: 1024px) { .controls-layer { display: flex; } }

    /* RESULTS */
    .result-win { color: var(--primary); }
    .result-lose { color: var(--secondary); }

    @keyframes popIn { 0% { transform: scale(0); } 80% { transform: scale(1.1); } 100% { transform: scale(1); } }
</style>
</head>
<body>

<div id="game-container">
    <div id="lobby-screen" class="screen">
        <h1>NITRO DUEL</h1>
        <p id="status-msg">Initializing Network...</p>
        <input type="text" id="player-name" placeholder="ENTER PILOT NAME" maxlength="8">
        <button id="find-match-btn" disabled>FIND MATCH</button>
        <p style="font-size: 0.8rem; margin-top: 20px; opacity: 0.6;">v1.0.0 | HTML5 | Firebase</p>
    </div>

    <div id="hud" class="hidden">
        <div class="top-bar">
            <div class="stat-box">POS: <span id="ui-pos">1/2</span></div>
            <div class="stat-box">DIST: <span id="ui-dist">0</span>m</div>
        </div>
        <div id="center-msg" class="center-msg"></div>
        <div class="speedometer">
            <div class="speed-val"><span id="ui-speed">0</span></div>
            <div class="speed-label">KM/H</div>
        </div>

        <div class="controls-layer">
            <div class="d-pad">
                <div class="btn-touch" id="btn-left">â—€</div>
                <div class="btn-touch" id="btn-right">â–¶</div>
            </div>
            <div class="pedals">
                <div class="btn-touch pedal-brake" id="btn-brake">ðŸ›‘</div>
                <div class="btn-touch pedal-gas" id="btn-gas">ðŸš€</div>
            </div>
        </div>
    </div>

    <div id="result-screen" class="screen hidden">
        <h1 id="result-title">FINISHED</h1>
        <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; text-align: center; margin-bottom: 20px;">
            <p>REWARD</p>
            <h2 id="result-reward" style="color: gold; font-size: 2rem;">0 COINS</h2>
        </div>
        <button onclick="location.reload()">MAIN MENU</button>
    </div>

    <canvas id="gameCanvas"></canvas>
</div>

<script>
/** * ------------------------------------------------------------------
 * 1. CONFIGURATION & FIREBASE SETUP
 * ------------------------------------------------------------------
 */
// TODO: PASTE YOUR FIREBASE CONFIGURATION HERE
const firebaseConfig = {

  apiKey: "AIzaSyDyEV80WZIwZE_7XTbCXOZv6nh5bMpXXhA",

  authDomain: "racing-game-14ba1.firebaseapp.com",

  databaseURL: "https://racing-game-14ba1-default-rtdb.firebaseio.com",

  projectId: "racing-game-14ba1",

  storageBucket: "racing-game-14ba1.firebasestorage.app",

  messagingSenderId: "361538843544",

  appId: "1:361538843544:web:be75f49647b2da97d131ed"

};


// Check if user configured firebase
if (firebaseConfig.apiKey === "YOUR_API_KEY") {
    alert("âš ï¸ SYSTEM ERROR: Firebase Config missing!\nPlease edit the HTML file and add your Firebase keys.");
}

// Init Firebase
firebase.initializeApp(firebaseConfig);
const db = firebase.database();
const auth = firebase.auth();

// ------------------------------------------------------------------
// 2. GAME VARIABLES & STATE
// ------------------------------------------------------------------
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let animationId;

// Physics Constants
const FPS = 60;
const STEP = 1/FPS;
const ROAD_WIDTH = 2000;
const SEGMENT_LENGTH = 200;
const TOTAL_DISTANCE = 50000; // 50km
const MAX_SPEED = 12000;
const ACCEL = MAX_SPEED / 5;
const BREAKING = -MAX_SPEED;
const DECEL = -MAX_SPEED / 5;
const OFFROAD_DECEL = -MAX_SPEED / 2;
const OFFROAD_LIMIT = MAX_SPEED / 4;

// Game State
let gameState = {
    active: false,
    started: false,
    finished: false,
    lastTime: 0,
    dtAccumulator: 0,
    banners: []
};

// Player Object
let player = {
    id: null,
    name: "Player",
    x: 0, // -1 to 1
    z: 0,
    speed: 0,
    lane: 0
};

// Opponent Object (Interpolation Target)
let opponent = {
    id: null,
    x: 0,
    z: 0,
    speed: 0,
    visible: false
};

// Input State
const input = { left: false, right: false, gas: false, brake: false };

// Networking State
let lobbyRef = null;
let playerRef = null;
let lobbyId = null;

// ------------------------------------------------------------------
// 3. NETWORK & MATCHMAKING LOGIC
// ------------------------------------------------------------------

// UI Elements
const uiLobby = document.getElementById('lobby-screen');
const uiHud = document.getElementById('hud');
const uiResult = document.getElementById('result-screen');
const btnFind = document.getElementById('find-match-btn');
const txtStatus = document.getElementById('status-msg');
const inpName = document.getElementById('player-name');

// Auth Listener
auth.onAuthStateChanged(user => {
    if (user) {
        player.id = user.uid;
        btnFind.disabled = false;
        txtStatus.innerText = "Connected to Server";
    } else {
        auth.signInAnonymously().catch(e => console.error(e));
    }
});

btnFind.addEventListener('click', () => {
    player.name = inpName.value || "Racer-" + Math.floor(Math.random()*1000);
    btnFind.disabled = true;
    txtStatus.innerText = "Searching for opponent...";
    findMatch();
});

function findMatch() {
    // Look for waiting lobby
    db.ref('lobbies').orderByChild('status').equalTo('waiting').limitToFirst(1).once('value', snap => {
        if (snap.exists()) {
            // Join existing
            const id = Object.keys(snap.val())[0];
            joinLobby(id, 2);
        } else {
            // Create new
            createLobby();
        }
    });
}

function createLobby() {
    lobbyId = db.ref('lobbies').push().key;
    lobbyRef = db.ref(`lobbies/${lobbyId}`);
    
    lobbyRef.set({
        status: 'waiting',
        created: Date.now(),
        host: player.id
    });

    joinLobby(lobbyId, 1);

    // Watch for opponent joining
    lobbyRef.child('players').on('child_added', snap => {
        if(snap.key !== player.id) {
            startCountdown();
        }
    });
}

function joinLobby(id, lane) {
    lobbyId = id;
    player.lane = lane;
    player.x = lane === 1 ? -0.5 : 0.5; // Start positions
    
    lobbyRef = db.ref(`lobbies/${lobbyId}`);
    playerRef = lobbyRef.child(`players/${player.id}`);

    playerRef.set({
        name: player.name,
        x: player.x,
        z: 0,
        speed: 0,
        lane: lane
    });

    playerRef.onDisconnect().remove(); // Cleanup

    // Listen to Game Status
    lobbyRef.child('status').on('value', snap => {
        if (snap.val() === 'starting') {
            uiLobby.classList.add('hidden');
            uiHud.classList.remove('hidden');
        }
    });

    // Listen to Opponent Data
    lobbyRef.child('players').on('value', snap => {
        const players = snap.val();
        if(!players) return;
        Object.keys(players).forEach(key => {
            if(key !== player.id) {
                const p = players[key];
                // Simple Interpolation would go here, direct set for now
                opponent.x = p.x;
                opponent.z = p.z;
                opponent.speed = p.speed;
                opponent.visible = true;
            }
        });
    });
}

function startCountdown() {
    lobbyRef.update({ status: 'starting' });
    
    let count = 3;
    const center = document.getElementById('center-msg');
    
    const intv = setInterval(() => {
        if(count > 0) {
            center.innerText = count;
            playTone(400, 0.1); // Beep
        } else {
            center.innerText = "GO!";
            playTone(800, 0.3); // High Beep
            gameState.started = true;
            gameState.active = true;
            clearInterval(intv);
            setTimeout(() => { center.innerText = ""; }, 1000);
        }
        count--;
    }, 1000);
}

// Network Sync Loop (Sends data 10 times a second)
setInterval(() => {
    if(gameState.started && !gameState.finished && playerRef) {
        playerRef.update({
            x: player.x,
            z: player.z,
            speed: player.speed
        });
    }
}, 100);

// ------------------------------------------------------------------
// 4. GAME ENGINE
// ------------------------------------------------------------------

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Generate Track Banners
for(let z=2000; z<TOTAL_DISTANCE; z+=4000) {
    gameState.banners.push({ z: z, type: z % 8000 === 0 ? 'AD' : 'CHECK' });
}

// Main Loop
function loop(time) {
    if(!gameState.lastTime) gameState.lastTime = time;
    const dt = (time - gameState.lastTime) / 1000;
    gameState.lastTime = time;

    if(gameState.active) {
        gameState.dtAccumulator += dt;
        while(gameState.dtAccumulator > STEP) {
            update(STEP);
            gameState.dtAccumulator -= STEP;
        }
    }
    
    render();
    animationId = requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

function update(dt) {
    // 1. Physics - Speed
    let accel = player.speed > OFFROAD_LIMIT && (player.x < -1 || player.x > 1) ? OFFROAD_DECEL : DECEL;
    
    if (input.gas) accel = ACCEL;
    else if (input.brake) accel = BREAKING;

    // Offroad penalty logic override
    if ((player.x < -1 || player.x > 1) && player.speed > OFFROAD_LIMIT) {
        accel = OFFROAD_DECEL;
    }

    player.speed += accel * dt;
    player.speed = Math.max(0, Math.min(player.speed, MAX_SPEED));

    // 2. Physics - Position
    player.z += player.speed * dt;

    // 3. Physics - Steering (Speed dependent)
    if(player.speed > 0) {
        const turn = (player.speed / MAX_SPEED) * 1.5;
        if(input.left) player.x -= turn * dt;
        if(input.right) player.x += turn * dt;
    }

    // 4. Win Condition
    if(player.z >= TOTAL_DISTANCE) {
        finishGame();
    }

    // 5. UI Updates
    document.getElementById('ui-speed').innerText = Math.floor(player.speed / 100);
    document.getElementById('ui-dist').innerText = Math.floor((TOTAL_DISTANCE - player.z)/100);
    
    const rank = (player.z >= opponent.z) ? 1 : 2;
    document.getElementById('ui-pos').innerText = `${rank}/2`;
}

function finishGame() {
    gameState.active = false;
    gameState.finished = true;
    player.speed = 0;
    
    // Send final update
    playerRef.update({ z: TOTAL_DISTANCE, speed: 0 });

    const won = player.z >= opponent.z;
    
    uiHud.classList.add('hidden');
    uiResult.classList.remove('hidden');
    
    const title = document.getElementById('result-title');
    title.innerText = won ? "VICTORY!" : "2ND PLACE";
    title.className = won ? "result-win" : "result-lose";
    
    document.getElementById('result-reward').innerText = won ? "500 COINS" : "100 COINS";
    
    if(won) playTone(600, 0.1);
}

// ------------------------------------------------------------------
// 5. RENDERING (PSEUDO 3D)
// ------------------------------------------------------------------
function render() {
    ctx.clearRect(0,0, canvas.width, canvas.height);

    const w = canvas.width;
    const h = canvas.height;
    
    // Sky
    const skyGrad = ctx.createLinearGradient(0,0,0,h);
    skyGrad.addColorStop(0, "#0b1026");
    skyGrad.addColorStop(0.5, "#2b1640");
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0,0,w,h);

    // Pseudo 3D Projection
    const fov = 100;
    const cameraHeight = 1000;
    const roadWidth = 2000;
    const camZ = player.z;
    const drawDistance = 30000; // How far we see

    // Helper: Project World Coordinate to Screen
    function project(objX, objY, objZ) {
        const scale = fov / (objZ - camZ);
        const x = w/2 + (objX * roadWidth/2) * scale;
        const y = h/2 + (cameraHeight) * scale; // Horizon center + height offset
        const width = roadWidth * scale;
        return { x, y, scale, width };
    }

    // 1. Draw Ground (Grass)
    ctx.fillStyle = "#163316";
    ctx.fillRect(0, h/2, w, h/2);

    // 2. Draw Road Segments
    // We draw from bottom of screen (near) to horizon (far)
    // Actually, painter's algorithm: draw far to near? 
    // For scanline road, it's easier to verify segments.
    
    // Optimized: Draw 50 segments
    const segmentCount = 100; 
    const horizonY = h/2;
    
    // Draw Road
    ctx.beginPath();
    // Simplified perspective polygon for road base
    ctx.moveTo(w/2, horizonY);
    ctx.lineTo(0, h);
    ctx.lineTo(w, h);
    ctx.fill();

    // Draw Stripes
    for(let i=0; i<segmentCount; i++) {
        const zWorld = Math.floor((camZ + i * SEGMENT_LENGTH)/SEGMENT_LENGTH) * SEGMENT_LENGTH;
        if (zWorld < camZ) continue;
        
        const p1 = project( -1, 0, zWorld );
        const p2 = project( 1, 0, zWorld );
        const p3 = project( 1, 0, zWorld + SEGMENT_LENGTH );
        const p4 = project( -1, 0, zWorld + SEGMENT_LENGTH );

        // Alternating colors
        const color = (Math.floor(zWorld / SEGMENT_LENGTH) % 2 === 0) ? '#333' : '#444';
        const kerbColor = (Math.floor(zWorld / SEGMENT_LENGTH) % 2 === 0) ? '#ff0000' : '#ffffff';

        if(p1.y <= horizonY) continue;

        // Road Surface
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.lineTo(p3.x, p3.y);
        ctx.lineTo(p4.x, p4.y);
        ctx.fill();

        // Kerbs (Left)
        ctx.fillStyle = kerbColor;
        ctx.fillRect(p1.x - p1.width*0.1, p1.y, p1.width*0.1, p4.y - p1.y);
        
        // Kerbs (Right)
        ctx.fillRect(p2.x, p2.y, p2.width*0.1, p3.y - p2.y);
        
        // Lane Marker
        if((Math.floor(zWorld / SEGMENT_LENGTH) % 2 === 0)) {
            ctx.fillStyle = '#fff';
            ctx.fillRect(p1.x + p1.width/2 - p1.width*0.02, p1.y, p1.width*0.04, p4.y - p1.y);
        }
    }

    // 3. Draw Banners
    gameState.banners.forEach(b => {
        if(b.z > camZ && b.z < camZ + drawDistance) {
            const proj = project(1.5, -2000, b.z); // Right side
            const bw = 300 * proj.scale;
            const bh = 150 * proj.scale;
            
            // Pole
            ctx.fillStyle = "#555";
            ctx.fillRect(proj.x, proj.y - bh*2, bw*0.1, bh*2);

            // Board
            ctx.fillStyle = b.type === 'AD' ? "#ffcc00" : "#00ffcc";
            ctx.fillRect(proj.x, proj.y - bh*2, bw, bh);
            
            ctx.fillStyle = "#000";
            ctx.textAlign = "center";
            ctx.font = `bold ${50*proj.scale}px Arial`;
            ctx.fillText(b.type, proj.x + bw/2, proj.y - bh*1.3);
        }
    });

    // 4. Draw Opponent
    if(opponent.visible && opponent.z > camZ && opponent.z < camZ + drawDistance) {
        const p = project(opponent.x, 0, opponent.z);
        drawCar(ctx, p.x, p.y, p.scale, '#ff0055', false);
    }

    // 5. Draw Player (Fixed Position mostly)
    // Add bounce and lean
    const bounce = Math.sin(Date.now()/50) * 2;
    const steerLean = (input.left ? -5 : 0) + (input.right ? 5 : 0);
    const playerScreenY = h - 100 + bounce;
    
    ctx.save();
    ctx.translate(w/2 + (player.x * w*0.3), playerScreenY); // Fake lateral movement on screen
    ctx.rotate(steerLean * Math.PI/180);
    drawCar(ctx, 0, 0, 1, '#00e5ff', true); // Scale 1 is base size
    ctx.restore();
}

function drawCar(ctx, x, y, scale, color, isPlayer) {
    const w = 120 * scale;
    const h = 60 * scale; // Height of car body
    
    // Shadow
    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.fillRect(x - w/2 + 10*scale, y - 10*scale, w, h);

    // Body
    ctx.fillStyle = color;
    // Draw trapezoid for car back
    ctx.beginPath();
    ctx.moveTo(
